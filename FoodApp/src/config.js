export const IMG_CDN_URL =
  'https://res.cloudinary.com/swiggy/image/upload/fl_lossy,f_auto,q_auto,w_508,h_320,c_fill/';
export const restaurantList = [
  {
    type: 'restaurant',
    data: {
      type: 'F',
      id: '98587',
      name: 'Sri Sai Fast Foods',
      uuid: '431094c0-0bf2-4807-b37b-ca0fb04a8715',
      city: '69',
      area: 'Khadi Colony',
      totalRatingsString: '1000+ ratings',
      cloudinaryImageId: 'stoha2ibifkd84slslpw',
      cuisines: ['South Indian', 'North Indian'],
      tags: [],
      costForTwo: 10000,
      costForTwoString: '₹100 FOR TWO',
      deliveryTime: 18,
      minDeliveryTime: 18,
      maxDeliveryTime: 18,
      slaString: '18 MINS',
      lastMileTravel: 3.9000000953674316,
      slugs: {
        restaurant: 'sri-sai-fast-foods-kt-road-korlagunta',
        city: 'tirupati',
      },
      cityState: '69',
      address:
        '6-1, 70 A, KT Rd, Srinivasa Nagar, Varadaraj Nagar, Tirupati, Andhra Pradesh 517501, India',
      locality: 'K T Road',
      parentId: 14024,
      unserviceable: false,
      veg: false,
      select: false,
      favorite: false,
      tradeCampaignHeaders: [],
      aggregatedDiscountInfo: {
        header: '30% off',
        shortDescriptionList: [
          {
            meta: '30% off | Use TRYNEW',
            discountType: 'Percentage',
            operationType: 'RESTAURANT',
          },
        ],
        descriptionList: [
          {
            meta: '30% off up to ₹75 | Use code TRYNEW',
            discountType: 'Percentage',
            operationType: 'RESTAURANT',
          },
        ],
        subHeader: '',
        headerType: 0,
        superFreedel: '',
      },
      aggregatedDiscountInfoV2: {
        header: '30% OFF',
        shortDescriptionList: [
          {
            meta: 'Use TRYNEW',
            discountType: 'Percentage',
            operationType: 'RESTAURANT',
          },
        ],
        descriptionList: [
          {
            meta: '30% off up to ₹75 | Use code TRYNEW',
            discountType: 'Percentage',
            operationType: 'RESTAURANT',
          },
        ],
        subHeader: '',
        headerType: 0,
        superFreedel: '',
      },
      ribbon: [
        {
          type: 'PROMOTED',
        },
      ],
      chain: [],
      feeDetails: {
        fees: [
          {
            name: 'distance',
            fee: 2100,
            message: '',
          },
          {
            name: 'time',
            fee: 0,
            message: '',
          },
          {
            name: 'special',
            fee: 0,
            message: '',
          },
        ],
        totalFees: 2100,
        message: '',
        title: 'Delivery Charge',
        amount: '2100',
        icon: '',
      },
      availability: {
        opened: true,
        nextOpenMessage: '',
        nextCloseMessage: '',
      },
      longDistanceEnabled: 0,
      rainMode: 'NONE',
      thirdPartyAddress: false,
      thirdPartyVendor: '',
      adTrackingID: 'cid=5832620~p=1~eid=00000186-43d8-a25d-3286-034000230157',
      badges: {
        imageBased: [],
        textBased: [],
        textExtendedBadges: [],
      },
      lastMileTravelString: '3.9 kms',
      hasSurge: false,
      sla: {
        restaurantId: '98587',
        deliveryTime: 18,
        minDeliveryTime: 18,
        maxDeliveryTime: 18,
        lastMileTravel: 3.9000000953674316,
        lastMileDistance: 0,
        serviceability: 'SERVICEABLE',
        rainMode: 'NONE',
        longDistance: 'NOT_LONG_DISTANCE',
        preferentialService: false,
        iconType: 'EMPTY',
      },
      promoted: true,
      avgRating: '3.7',
      totalRatings: 1000,
      new: false,
    },
    subtype: 'basic',
  },
  {
    type: 'restaurant',
    data: {
      type: 'F',
      id: '218280',
      name: "Sakhi Tiffin's",
      uuid: '2bb83450-ae1b-40ab-89e4-f6492473cf1a',
      city: '69',
      area: 'Royal Nagar',
      totalRatingsString: '5000+ ratings',
      cloudinaryImageId: 'ndw1xehee8dyt2b4xk54',
      cuisines: ['South Indian', 'North Indian'],
      tags: [],
      costForTwo: 15000,
      costForTwoString: '₹150 FOR TWO',
      deliveryTime: 14,
      minDeliveryTime: 14,
      maxDeliveryTime: 14,
      slaString: '14 MINS',
      lastMileTravel: 0.800000011920929,
      slugs: {
        restaurant: "sakhi-tiffin's-korlagunta-korlagunta",
        city: 'tirupati',
      },
      cityState: '69',
      address:
        'AIR Bypass Road,Next to Chillies Restaurant, STV Nagar, Bairagi patteda, Tirupati, Andhra Pradesh 517501',
      locality: 'Air By Pass Road',
      parentId: 14055,
      unserviceable: false,
      veg: true,
      select: false,
      favorite: false,
      tradeCampaignHeaders: [],
      aggregatedDiscountInfo: {
        header: '60% off',
        shortDescriptionList: [
          {
            meta: '60% off | Use TRYNEW',
            discountType: 'Percentage',
            operationType: 'RESTAURANT',
          },
        ],
        descriptionList: [
          {
            meta: '60% off up to ₹120 | Use code TRYNEW',
            discountType: 'Percentage',
            operationType: 'RESTAURANT',
          },
        ],
        subHeader: '',
        headerType: 0,
        superFreedel: '',
      },
      aggregatedDiscountInfoV2: {
        header: '60% OFF',
        shortDescriptionList: [
          {
            meta: 'Use TRYNEW',
            discountType: 'Percentage',
            operationType: 'RESTAURANT',
          },
        ],
        descriptionList: [
          {
            meta: '60% off up to ₹120 | Use code TRYNEW',
            discountType: 'Percentage',
            operationType: 'RESTAURANT',
          },
        ],
        subHeader: '',
        headerType: 0,
        superFreedel: '',
      },
      chain: [],
      feeDetails: {
        fees: [
          {
            name: 'distance',
            fee: 2100,
            message: '',
          },
          {
            name: 'time',
            fee: 0,
            message: '',
          },
          {
            name: 'special',
            fee: 0,
            message: '',
          },
        ],
        totalFees: 2100,
        message: '',
        title: 'Delivery Charge',
        amount: '2100',
        icon: '',
      },
      availability: {
        opened: true,
        nextOpenMessage: '',
        nextCloseMessage: '',
      },
      longDistanceEnabled: 0,
      rainMode: 'NONE',
      thirdPartyAddress: false,
      thirdPartyVendor: '',
      adTrackingID: '',
      badges: {
        imageBased: [],
        textBased: [],
        textExtendedBadges: [],
      },
      lastMileTravelString: '0.8 kms',
      hasSurge: false,
      sla: {
        restaurantId: '218280',
        deliveryTime: 14,
        minDeliveryTime: 14,
        maxDeliveryTime: 14,
        lastMileTravel: 0.800000011920929,
        lastMileDistance: 0,
        serviceability: 'SERVICEABLE',
        rainMode: 'NONE',
        longDistance: 'NOT_LONG_DISTANCE',
        preferentialService: false,
        iconType: 'EMPTY',
      },
      promoted: false,
      avgRating: '3.8',
      totalRatings: 5000,
      new: false,
    },
    subtype: 'basic',
  },
  {
    type: 'restaurant',
    data: {
      type: 'F',
      id: '607702',
      name: 'Pulse Grameena Biryani',
      uuid: '446ce330-ae30-451a-9bee-4d46cb0bed3a',
      city: '69',
      area: 'Tata Nagar',
      totalRatingsString: '500+ ratings',
      cloudinaryImageId: 'w7fktuea0z4p0duehcg4',
      cuisines: ['Biryani', 'North Indian', 'Seafood'],
      tags: [],
      costForTwo: 30000,
      costForTwoString: '₹300 FOR TWO',
      deliveryTime: 15,
      minDeliveryTime: 15,
      maxDeliveryTime: 15,
      slaString: '15 MINS',
      lastMileTravel: 0.30000001192092896,
      slugs: {
        restaurant: 'pulse-grameena-biryani-tata-nagar-tata-nagar',
        city: 'tirupati',
      },
      cityState: '69',
      address:
        '19,Kesavayangunta ,Raghavendra Nagar, Near SGS College ,Tirupati',
      locality: 'Konkachennaiahgunta',
      parentId: 361582,
      unserviceable: false,
      veg: false,
      select: false,
      favorite: false,
      tradeCampaignHeaders: [],
      aggregatedDiscountInfo: {
        header: '60% off',
        shortDescriptionList: [
          {
            meta: '60% off | Use TRYNEW',
            discountType: 'Percentage',
            operationType: 'RESTAURANT',
          },
        ],
        descriptionList: [
          {
            meta: '60% off up to ₹120 | Use code TRYNEW',
            discountType: 'Percentage',
            operationType: 'RESTAURANT',
          },
        ],
        subHeader: '',
        headerType: 0,
        superFreedel: '',
      },
      aggregatedDiscountInfoV2: {
        header: '60% OFF',
        shortDescriptionList: [
          {
            meta: 'Use TRYNEW',
            discountType: 'Percentage',
            operationType: 'RESTAURANT',
          },
        ],
        descriptionList: [
          {
            meta: '60% off up to ₹120 | Use code TRYNEW',
            discountType: 'Percentage',
            operationType: 'RESTAURANT',
          },
        ],
        subHeader: '',
        headerType: 0,
        superFreedel: '',
      },
      chain: [],
      feeDetails: {
        fees: [
          {
            name: 'distance',
            fee: 2100,
            message: '',
          },
          {
            name: 'time',
            fee: 0,
            message: '',
          },
          {
            name: 'special',
            fee: 0,
            message: '',
          },
        ],
        totalFees: 2100,
        message: '',
        title: 'Delivery Charge',
        amount: '2100',
        icon: '',
      },
      availability: {
        opened: true,
        nextOpenMessage: '',
        nextCloseMessage: '',
      },
      longDistanceEnabled: 0,
      rainMode: 'NONE',
      thirdPartyAddress: false,
      thirdPartyVendor: '',
      adTrackingID: '',
      badges: {
        imageBased: [],
        textBased: [],
        textExtendedBadges: [],
      },
      lastMileTravelString: '0.3 kms',
      hasSurge: false,
      sla: {
        restaurantId: '607702',
        deliveryTime: 15,
        minDeliveryTime: 15,
        maxDeliveryTime: 15,
        lastMileTravel: 0.30000001192092896,
        lastMileDistance: 0,
        serviceability: 'SERVICEABLE',
        rainMode: 'NONE',
        longDistance: 'NOT_LONG_DISTANCE',
        preferentialService: false,
        iconType: 'EMPTY',
      },
      promoted: false,
      avgRating: '3.5',
      totalRatings: 500,
      new: false,
    },
    subtype: 'basic',
  },
  {
    type: 'restaurant',
    data: {
      type: 'F',
      id: '650507',
      name: 'Fb Cakes',
      uuid: '56c41582-3029-488a-ac94-5b4507e09429',
      city: '69',
      area: 'Korlagunta',
      totalRatingsString: 'Too Few Ratings',
      cloudinaryImageId: 'a53bdeed939ae720286d75b1428916dd',
      cuisines: ['Bakery', 'Sweets', 'Snacks'],
      tags: [],
      costForTwo: 150000,
      costForTwoString: '₹1500 FOR TWO',
      deliveryTime: 24,
      minDeliveryTime: 24,
      maxDeliveryTime: 24,
      slaString: '24 MINS',
      lastMileTravel: 2.9000000953674316,
      slugs: {
        restaurant: 'fb-cakes-korlagunta-korlagunta',
        city: 'tirupati',
      },
      cityState: '69',
      address:
        'D.NO:18-2-299 / A1,GROUND & 1ST FLOOR,ASHOK NAGAR,TIRUPATI,ANDHRA PRADESH-517501, Tirupati (Rural), Tirupathi, Andhra Pradesh-517501',
      locality: 'Ashok Nagar',
      parentId: 245423,
      unserviceable: false,
      veg: false,
      select: false,
      favorite: false,
      tradeCampaignHeaders: [],
      aggregatedDiscountInfo: {
        header: 'Flat ₹125 off',
        shortDescriptionList: [
          {
            meta: 'Flat ₹125 off on orders above ₹199',
            discountType: 'Flat',
            operationType: 'RESTAURANT',
          },
        ],
        descriptionList: [
          {
            meta: 'Flat ₹125 off on orders above ₹199 | Use code FLAT125',
            discountType: 'Flat',
            operationType: 'RESTAURANT',
          },
        ],
        subHeader: '',
        headerType: 0,
        superFreedel: '',
      },
      aggregatedDiscountInfoV2: {
        header: '₹125 OFF',
        shortDescriptionList: [
          {
            meta: 'Use SWIGGYWEEKENDS',
            discountType: 'Flat',
            operationType: 'RESTAURANT',
          },
        ],
        descriptionList: [
          {
            meta: 'Flat ₹125 off on orders above ₹199 | Use code FLAT125',
            discountType: 'Flat',
            operationType: 'RESTAURANT',
          },
        ],
        subHeader: '',
        headerType: 0,
        superFreedel: '',
      },
      ribbon: [
        {
          type: 'PROMOTED',
        },
      ],
      chain: [],
      feeDetails: {
        fees: [
          {
            name: 'distance',
            fee: 2100,
            message: '',
          },
          {
            name: 'time',
            fee: 0,
            message: '',
          },
          {
            name: 'special',
            fee: 0,
            message: '',
          },
        ],
        totalFees: 2100,
        message: '',
        title: 'Delivery Charge',
        amount: '2100',
        icon: '',
      },
      availability: {
        opened: true,
        nextOpenMessage: '',
        nextCloseMessage: '',
      },
      longDistanceEnabled: 0,
      rainMode: 'NONE',
      thirdPartyAddress: false,
      thirdPartyVendor: '',
      adTrackingID: 'cid=5839507~p=4~eid=00000186-43d8-a25d-3286-034100230446',
      badges: {
        imageBased: [],
        textBased: [],
        textExtendedBadges: [],
      },
      lastMileTravelString: '2.9 kms',
      hasSurge: false,
      sla: {
        restaurantId: '650507',
        deliveryTime: 24,
        minDeliveryTime: 24,
        maxDeliveryTime: 24,
        lastMileTravel: 2.9000000953674316,
        lastMileDistance: 0,
        serviceability: 'SERVICEABLE',
        rainMode: 'NONE',
        longDistance: 'NOT_LONG_DISTANCE',
        preferentialService: false,
        iconType: 'EMPTY',
      },
      promoted: true,
      avgRating: '--',
      totalRatings: 0,
      new: false,
    },
    subtype: 'basic',
  },
];
export const mainUrl = 'https://mockapi-swiggy.onrender.com/api';
export const menuUrl = 'https://mockapi-swiggy.onrender.com/api/menu/';
export const emptyCartURl =
  'https://res.cloudinary.com/swiggy/image/upload/fl_lossy,f_auto,q_auto/2xempty_cart_yfxml0';

const mockApiRailwayURL = 'https://mockapi-swiggy.up.railway.app/api';

export const docsData = {
  info: `TreeShaking: Bundlers will remove the unnecessary code in out application 
  Like, removing unwanted/unused methods/functions of a library we installed in app.


npx is used to execute a package where as npm is used to install/run
  npm is simillar to 'npm run ...'


in package.json, there is a browserlists section. babel uses this data to transpile the code to support these browsers listed
  [ i.e, all browsers will be supported, but these listed browsers must be supported. these browsers will be tragetted first. 
      polyfills are written accordingly.]

_________________________________________________________________

JSX should only have one parent. So either wrap the jsx with a div/React.Fragment component(<></>)

When u build a realworld application, we need our application to be dynamic based on the location/info etc... Basically, a dynamic UI
  Data will be sent from thr backend api, so we should use this data and build the frontend based on the UI. which is called as
  "Config Driven UI/Dynamic UI"

_________________________________________________________________

In functional component, All the arguments passed to the function component (or function) will be 
  wrapped a single variable called props. Props are properties that we pass to a children compoent that we can
  access in the component using props variable.


function f(param1,param2){} //params 
f(arg1,arg2) //arguments

_________________________________________________________________

- If we have multiple props to pass and we have a data as an object, we can just use spready syntax to 
  to pass all properties at once.

_________________________________________________________________


[ React handles this internally ]In react,We keep the representation of DOM with us known as "Virtual DOM".
  - We need virtual dom in react for "reconcilliation"[ The process of syncing Virtual DOM with the real DOM.] 
   reconcilliation involves an algorithm that react uses
   to diff one DOM tree from another(Virtual DOM) which is also known as Diffing algorithm
   and it determines what needs to changed/unchanged in the UI.
  ]

  - reconcilliation : renders a component -> constructs virtual DOM -> Checks for changes btwn
                     DOM & V-DOM if there are any changes -> updates the specific changes -> rerenders the component 
- In React16, React-Fiber was introduced, which is a new reconcilliation engine. This new reconcilliation engine    
  is responsible for new diffing algorithm that improves the react and makes it faster.

_________________________________________________________________

Always prefer using a unique id as value for the key attribute in a list and avoid using index.
Using index might result in performance issues and data binding issues in case 
  reordering in the form of sorting, filtering might happen.

_________________________________________________________________
`,
  exports: `- A component can be exported in two ways. 
Named Export & Default export

Named Export
    export const App=()=<></>
Default Export
    const App=()=><></>
    export default App;

- These components/items can be imported in any component/js file as follows.
Named Imports { Components which are exported as named exports}
    import {App} from '<file path>'
Default Imports
    import App from '<file path>'

- There can be only one default export from a file.

___________________________________________________________________________________________

Everytime we need our variables to be in sync with the UI. So we need to use state variables [ useState]
which rerenders the component whenever state changes.

___________________________________________________________________________________________

`,
  hooks: `Whenever state changes, compoent rerenders and the the changes only will be updated in the component.

- useEffect Hook
    Component will be rendered and the useEffect will be called based on the dependency array.
    - If state changes & state is passed as an dependency array, component will be rendered first and then the 
      useEffect will be executed again.


Browsers will stop the api requests to cross origin requests. to avoid this error, use CORS Plugin.
    - Or, in the backend api, allow cors.



useState shouldnt be called inside loops/conditional statements. Also,
  useState shouldnt be used outside the functional component.
  as useState is a method provided by react to create a local state in fn component.

Hooks should be called in the top section of the functional component and shouldnt be
used inside blocks [ if/for etc..]. Whenever component rerenders, these hooks should be called
in the same order. if they are used inside loops/blocks/conditional statements there is a chance
that these hooks might not be called. so we will get an error and application crashes.


We can set new value to the state or do operations on the state as follows:
  setCount(count+1)
But in the above case, if we multiple setState operations, all setStates will refer to the state of
the component during current render. 
  setCount(count+1)
  setCount(count+1)

  in this case both set states will refer to same count variable[value]. so if the current state value is 1,
  after performing these setCount operations value will be still 2.

setter function will take a callback fn which gets the prevState as a param.
we can use prevState to perform required operations and return the new value.

  setCount((prevCount)=>prevCount+1)

  if we have multiple operations, each operation will refer to the updated value.
    setCount((prevCount)=>prevCount+1)
    setCount((prevCount)=>prevCount+1)

    this will update the value to 3 if initial value is 1.

______________________________________________________________________________________________________________

IMPORTANT

Whenever we use Class Components, state will be initiated inside a constructor method.
So setting the state will be done only once when the component first rendered.
But in functional component, using useState() hook, state will be set every time the component renders.

When it's a harcoded value it doesnt matter. but let's say we have a complex computation involved 
while setting the state using useState, as this will be called everytime performance of the application
will be impacted. 

In order to solve this problem, useState hook can be also used with a callback function instead of hardcoding the value.
if we took this approach, this setting up the state will be done only once when the component initially renders.

  useState(()=>{return <some value>})

  if we created this entire callback function as a normal function outside the fn component,
  it will not work as expected and calls the function everytime. so always use the callback anonymous fn format as above.
______________________________________________________________________________________________________________

While using objects as an initial state, in class components we can just update the value of the specific property
and it will only update the value of that property only. But in fn components, if we do the same thig entire 
object will be modified and the property which is modified only will be present in the object.

  in class component
    initial State -> assume {count:1,color:'blue'}
    setState(count:count+1) will only make changes to the count.

  in fn component, if we do the same thing color property will be lost.
  to avoid this, either use seperate state for both properties.

  or use spread syntax and get all the properties and update the required property.
  setState((prevState)=>{return {...prevState,count:count+1}})
`,
  tailwind: `in order to use tailwind, we can add tailwind cdn url in our root html file
(<script src="https://cdn.tailwindcss.com"></script>)
or
install tailwindcss & postcss npm packages and configure.

initialize tailwindcss by running the below command - npx tailwindcss init

- inside the tailwind.config.js file, for content property, we need to add the files 
  where we might use our tailwind css classes.
  example: content: ['./src/**/*.{html,js,jsx}'],

  Note: talwind.config.css and .postcssrc should be in same directory

  and then create a postcssrc file to mention that we are using tailwind in our project.`,
  routing: `in order to implement routing, we use react-router-dom library.

  - We will use BrowserRouter to implement the routing.
      in the app component (or compoenent which we will render in root), we can write code as below.
      ______________________________________________________________________________
          import { BrowserRouter, Routes, Route } from 'react-router-dom';
  
          const AppLayout = () => {
              return (
                  <>
                  <Header />
                  <BrowserRouter>
                      <Routes>
                      <Route path='/' exact element={<Body />} />
                      <Route path='/about' element={<About />} />
                      <Route path='*' element={<h1>Not Found</h1>} />
                      </Routes>
                  </BrowserRouter>
                  <Footer />
                  </>
              );
          };

          Here, we are importing BrowserRouter Component and we can use Routes component to group the Routes
          and inside routes component, use Route component to pass path and relevant element you want to render 
      ______________________________________________________________________________
      
      Instead of components given by react-router-dom, we can also use 
      createBrowserRouter Function and RouterProvider [Context ]
      to implement routing. 
  
      We need to use createBrowserRouter to create the router with the path and relevant component to rendera
      and pass this router as a param to RouterProvider Component that we will render in the root div.
  
          const appRouter = createBrowserRouter([
          {
              path: '/',
              element: <AppLayout />,
              errorElement: <Error />,
              children: [
              {
                  path: '/',
                  element: <Body />,
              },
              {
                  path: '/about',
                  element: <About />,
              },
              {
                  path: '/contact',
                  element: <Contact />,
              },
              ],
          },
          ]);
  
          const root = ReactDOM.createRoot(document.querySelector('#root'));
          root.render(<RouterProvider router={appRouter} />);
  
      pass config object to createBrowserRouter fn, with path and element to render.
      for base route, add errorElement property, if no path matched, render an error component.
  
  _________________________________________________________________________________
  If path started with / it will start the path from domain [ localhost:1234/]
  for relative paths, dont start with '/', so that path will be 
  constructed from the current page we are in.
  
  we can use useParams() hook to ghet the params data. and to get the error data 
  related to routes, we can use useRouteError() hook
  
  ____________________________________________________________________________________
  
  `,
  lazy_Loading: `Generally, Bundlers will bundle all the available code/components
   into a single JS bundle and send to the client to render the
  application and If we have a very large application with too many components & business logic involved,
  Out bundle size will grow eventually and it will take more time load the application.
  
  In order to reduce the bundle size, we need to dynamically import / lazy load
   the components which we don't require whileloading a specific part of the appliaction.
  
  For example, there's no point in including /route1 related components when we loads the / route.
  so we can use lazy loading to load the components of /route1 page only when a request was sent to that route.
  
  use lazy method from react library.
  Example: const Instamart = lazy(() => import('./components/Instamart'));
  
  lazy method takes a callback where we need to use import method and specify the path to the component
  file that we need to lazy load.
  
  
  ________________________________________________________
  
  
  Because lazy loading a component is asynchronous event, it might take some time to load the
  component, and if rreact tries to render the component in that mean time, we might get an error.
  
  To avoid the error, we need to wrap our lazy loaded component with a Suspense component so that 
  this component will be rendered only when its avaialble.
  
  Suspense component takes a prop : fallback where we can specify a 
  fallback UI if the component isnt loaded yet.`,
  context: `in order to avoid Props drilling, we can use context in react applications.

  Context is like a central store to save our data in our application.
  
  
  we can create as many contexts as we need using createContext method and we can export these contexts 
  and can use the context data across the components in the application.
  
          const UserContext = createContext({
              user: {
                  name: 'Surya Venkatesh Vijjana',
                  email: 'suryavenkatesh0@gmail.com',
              },
          });
  
  in order to use this data in any component, import useContext hook and 
  import the context created in the component.
  
      import UserContext from '../utils/UserContext';
      import { useContext } from 'react';
  
      const { user } = useContext(UserContext);
  
  
  __________________________________________________________________________________________
  
  
  Inside class components we can't use useContext hook. But we can use the context we created and there's a
  Property attached to it. Inside the class component we can use Context.consumer to get the data.
  
  Inside the Context.Consumer we can write jsx where we will get the context data as a single variable and we 
  can use that to build jsx elements.
  
      <UserContext.Consumer>
            {({ user }) => (
              <>
                <small>{user.name, user.email}</small>
              </>
            )}
       </UserContext.Consumer>
  
  __________________________________________________________________________________________
  
  To distinguish different contexts created in dev tools, we can add a display name to our context as below.
      Context.displayName='UserContext' 
  Now if we check in React Dev 
  
  Instead of hardcoding the data we can get the dynamic data and pass the data across the 
  application using Context.Provider component. 
  
  We need to wrap the components with Context.Provider in which we want to use the data.
  we can pass any data [ states/ setter functions etc...] as value prop 
  to the Context.Provider component and this data can be accessed 
  from any components enclosed in Context.Provider.`,
  redux: `In redux, store data should not be mutated/modified directly. We need to follow the architecture.

  In store, we can create multiple slices of data [ ex: slice for cart/menu/theme etc...]
  
  When we interact with frontend, [like clicking a button / searching etc...] 
      lets say we clicked a button to add an item to cart, we will dispatch an action named 'addItem'
      with a payload data and this action will be used to call a function [known as reducer] which 
      is responsible to modify the store data.
  
      Simillary, if we want to read data from the store, we should use selector to get the data from store.
      when we are using selector, it's known as subscribing to the store, i.e component is subscribing to the store.
  
      If we used selector in cart component, cart component is subscribing to the store. i.e,
      cart component is in sync with the store. so, whenever the store modified, cart component will
      automatically modifies.
  
  ___________________________________________________________________________________________________________________
  
  We have to use 2 libraries to setup and use the store as discussed above.
      @reduxjs/toolkit and react-redux 
  
      @reduxjs/toolkit : is responsible for core redux stuff like creating the store/actions/reducers etc
      react-redux: library is responsible for linking the redux with the react application.
  
  ___________________________________________________________________________________________________________________
  
  First we need to create the store using configureStore method from the @reduxjs/toolkit library and export it.
  
  use Provider component from react-redux library to wrap the entire application / the components in 
  which we want to access the store data and pass store we exported as a store prop.
  Now we can access the store across all components in out application.
  
  We need to create a slice using createSlice method imported from @reduxjs/toolkit
  which handles storing the actions and reducers. 
  [ We can create as many slices as we need ]
  
  createSlice takes an object as an argument. that has following properties.
      name: name of the slice
      initialState: we need to define the initial state
      reducers: an object with action names as key and a reducer function as value that takes state
                and action as params. Initially, state will be equal to intialState and action will 
                be passed when we dispatch an action from a component.
  
                in reducer, function we dont need to return anything. we can perform 
                required operations on the state data directly.
  
      Exporting the slice is a little tricky in @reduxjs/toolkit implementation.
  
      createSlice will create a slice (lets say cartSlice) and it will have 2 properties.
  
      all reducers in the slice will be bundled into a single reducer and will be added as a 
      reducer property in the cartSlice object. we can default export to export this property.
  
      all actions will be stored in the actions property of the cartSlice object.
  
  
  Now we need to put this slice in our store.
  in our store configuration, we need to add reducer property and add all the slices/reducers we 
  created By specifying our slice name as key and default export as value.    
  if we have multiple slices created, add all slices here.
  
      Example: reducer:{
          cart:cartSlice,
          user:userSlice
      }
  
  ___________________________________________________________________________________________________________________
  
  Now we need to subscribe to the store using useSelector hook from react-redux.
  useSelector hook will take a callback fn and it takes store as a param.
  
  we can perform any operations on the store and return the data and we can use this data in the component.
      Example: const cartItems = useSelector((state) => state.cart.items);
  
  If we need to perform an action, then we need to dispatch an action from component 
  using dispatch method[ import from react-redux]
      dispatch method will take reducer method as a param and reduver fn will take action payload as param.
  
      Example: const dispatch =useDispatch()
               dispatch(addItem('item'))
  
               here addItem is the reducer fn and 'item' is the payload.
  
  ___________________________________________________________________________________________________________________
  
  
  When using useSelector always filter out [ or subscribe] to specific slice/ part of the slice as
  when we subscribe component will be rerendered whenever there's a change in the store/slice/part of the slice.
  if we susbcribed to the unnecessary data part of the store, our component rerenders even if we aren't 
  using thata data which affects the app's performance.
  ________________________________________________________
  
  Wrap the RouterProvider component that we render in the root with the Provider component
  so that if there's an error, and if we need to display some data from the store in the 
  Error component, application will not break and displays the required data.`,
  redux_Thunk: `By default, redux action creator expects a action type string and a payload. 
  Anything part from these will throw an error.
  
  So, if we need to fetch data from an api and store in redux store we need to
  write asynchronous function to fetch the data in the action. To handle this, 
  we need to use thunk.[ Thunk -> function is used to delay the evaluation/calculation of an operation ]
  
  in @reduxjs/toolkit library, we have a method called 'createAsyncThunk' which can be
  used to create asynchronous actions. 
  
  import createAsyncThunk from the @reduxjs/toolkit library.
  this method accepts two params. Action type string used to identify the action
  and an function that returns a promise.
  
      export const getTodos = createAsyncThunk('todos/getTodos', async () => {
      const { data } = await axios.get(
          'https://jsonplaceholder.typicode.com/todos'
      );
          return data;
      });
  
  instead of adding the reducer logic in reducers, slice has another property 'extraReducers'.
  extraReducers is a method that takes builder object as a param.
  
  use builder.addCase to add cases [ pending,fulfilled,rejected ] that replicates promise states.
  
      Example: builder.addCase(getTodos.pending, (state, action) => {
        state.isLoading = true;
      })
  
  ______________________________________________________________________________________________________
  
  In the component you want to use this data, import the action and in dispatch method call this action method.`,
  testing_Setup: `As a developer, we need to take care of Unit & Integration testing.
  For that we need to use React-testing-Library and Jest [ RTL used jest in background]
  
      npm i -D @testing-library/react
      npm i -D jest
  
  Now we need to initialise jest
      run the below command to initiate jest
          npx jest --init
      and follow the configuration prompts[ choose jsdom & babel ].
  
  install jest-environment-jsdom [ missing dependency]
  
  -> Upon installing all required libraries and configured jest
     on running 'npm run jest' command, We shouldn't get an error
     as we didnt define any tests yet.
  
  We can create test files in two ways.
  
      Create a folder with exact name '__tests__' and include the test files [ js/ts]
      Any file[js/ts] inside this folder, jest will consider them as test files.
      or
      Create test files with the mentioned format.
          <filename>.[spec or test].[js or ts or jsx/tsx]
  
  As a standard practise, we will create __tests__ folder and 
  include or test files with .test.js format.
  
  We use jsdom as a dependency, bcoz we are not running our tests in a browser.
jsdom will be used to create a headless browser environment where our 
tests will be executed by jest in a browser like environment using jsdom.
This will be significantly faster compared to checking in browser as Here
we dont need to complex dom painting operations.`,
  js_Testing: `Writing Our First Test case.

Inside the test file, we need to import the functions we want 
to test and use test() method.

test method is provided by jest and it takes two params.
    a string to identify the test and a callback fn.

    without writing anything insdie the callback fn and running the tests
    will result in a success case. As test fn isn't expecting anything.

Every testcase should have an expectation [ Assertion ].
We need to use expect() method provided by jest inside callback fn.

    Example: expect(sum(2,5)).toBe(7)
             -> Here, we are testing sum fn to return '7' when 2,5 passed as args.

Unlike react files, we can't import anything inside test files directly using import statements.
We need to configure jest with babel in order to use import statements in test files.

    -> TO configure babel with jest, we need to install few packages as dev dependencies.

       npm i -D babel-jest @babel/core @babel/preset-env

    -> After Installing, we need to configure babel [ either use babel.config.js / .babelrc file ]
       
       Add the below line in .babelrc file.
        -> {
            "presets": [["@babel/preset-env", { "targets": { "node": "current" } }]]
            }`,
  testing_Basics: `Just like how we did test testing for js functions, we can use jest/RTL to
  test our React Components. In order to write test cases for our react 
  Components, We need to make few configurations in our .babelrc file.
  
      -> add this to .babelrc file 
         ["@babel/preset-react", { "runtime": "automatic" }]
      and install @babel/preset-react package as dev dependency.
  
  To write test cases for a react component, import the component to the test file.
  
  RTL provides a method called - render() which can be used to render components in js dom.
  
  jsdom cannot render images. so if the component has any images then we need
  to mock the images so that jsdom can understand and render the component.
  
      in order to mock, create a mocks folder. and create a js file
      -> in the js file, export a string as a default export.
  
      and now we need to map images to this dummyImage mock we created.
      -> In jest.config.js file, we need to use moduleNameMapper property.
         Add the key valeu pair in moduleNameMapper object.
  
         '\\.(png|jpg|jpeg|svg)$': '../mocks/dummyImage.js'
  
         a regular expression that checks for .png/.jpg/.jpeg/.svg and
         maps the dummy js file we created inside mocks directory.
  
  -> Because we are using Redux store data in our header component we need to
     get the store data in order to render the Header in jsdom. or we will get an error.
  
     Import provider & store and wrap the header component with the Provider.
  
  -> Also bcoz we are using Link for routing in header component. 
     We need to wrap our component with a router.
  
     Since, we are rendering the component in jsDom, we cant use browserRouter like
     we used in our react component. So, we need to use staticRouter provided by
     react-router-dom/server library.
  
     import StaticRouter component and wrap the components we need to test.
  
  Now if we run the tests, tests will succeed but we didn't test anything so far.
  Now we need to write an expect method to test the component.
  
  
  In browser, we can get access to any element using document.getElementById/className/tagName
  but here we are rendering the component in jsDOM, so we need to add data attribute to our jsx
  to access the element. jest accesses the element by using .getByTestId/.getAllByTestId methods.
  
      -> add data-testid attribute with a value to the element we want to grab in testing.
  
  getByTestId returns single object where as getAllByTestId returns an array even if there's a single element.
  
  after fetching the logo element, write a expect method to check if it has a src attribute mapped to
  the string we exported from the mock dummyImage.js file.
  
  Simillarly, if we want to check if the header component has cart items set to 0 when 
  the component initially renders, follow the same process as above and instead of src attribute check for 
  innerHTML property and check if thhe values matches to "0".
  `,
  testing_Advanced: `While testing a component, if we have functions related to browser like
  window.scrollTo etc they will not work in jsDOM as jsDOM will not have 
  window object. so we need to mock these functions.
  
  jest provides method called fn() in which we can define our mock function
  We can use this to simiulate the function behaviour.
  
      add these functions as part of the global object.
          -> global.<function we want to mock>
  
      Example: window.scrollTo() throws an error
               so create a mock function.
  
               global.scrollTo=jest.fn()
  
               fn() takes a callback fn as param. use this callback fn to write
               simulation logic. 
  
  
      Example2: fetch is limited to browser. so if we use fetch to fetch the api data
                in our application then we need to mock the fetch method.
  
  
                //fetch returns a promise and we apply .json method of the returned promise
                to convert the ReadableStream to json which again returns a promise.
  
                global.fetch=jest.fn(()=>{
                  return Promise.resolve({
                      json:()=>Promise resolve(data) //create a js file in mocks and export mockData
                  })
                })
  
      Example 3: mocking axios.get method
                 //get method returns a promise.
                 global.axios = {
                                  get: jest.fn(() => {
                                      return Promise.resolve(data);
                                  }),
                              };
  
                 or
                 
                 instead of writing promise we can directly send the data using mockResolvedValue method.
                 global.axios={
                  get:jest.fn().mockResolvedValue({data})
                 }
  
  Testing if shimmer is loading when we are fetching the data.
      check for shimmer component and to test if shimmer is working as expected,
      we can check the count of shimmer children [ shimmer cards ] as we created 10 card components.
      
      or
  
      we can just check if shimmer is present in the current document using
      .toBeInTheDocument() method which is provided by @testing-library/jest-dom
  
  
  Suppose we are testing for the totalRestaurants data in the body component or
  for the RestaurantCard component to render. which takes some time to render
  as we need to fetch the data from an api and then render the data.
  
      we need to wait for the component to render. so while testing the component,
      we can use waitFor() method which is provided by RTL.
  
      waitFor() takes a callback fn in which we can write our testing logic.
      This will wait until the element renders.
      Along with callback fn, we can pass an optional second argument which is an object.
      we can pass timeout/inmterval properties in this object.
      default values will be 50ms for interval and 1000ms for timeout.
  
      tests will be called for every 50ms upto 1000ms.
  
          only use this if the async component we are testing will take
          more than 1000ms.
  
          Example: await waitFor(()=>{expect(body.getByTestId('searchBtn'))})
                   waiting for searchBtn to render in the body component.
  
          Example2: await waitFor(()=>{expect(body.getByTestId('resList))},{timeout:5000})
  
      Beacuse we are using await, we need to add async to our test method callback fn.
  
  just like .toBe() we can also use .not.toBe() to check if value isnt equal to value provided.`,
  testingFinal: `So far we are just testing for the component to render and 
  writing our test cases based on the UI elements.
  
  Now we have to write test cases for the events that are fired from 
  our components like typing/onChange/onClick etc.
  
  If we have a text box and if we need to mock typing data in text field,
  we need to fire a typing/onChange event. RTL provided fireEvent method.
  
      to fire an change event, use change method present on the fireEvent method
      fireEvent.change(<target element>,{})
  
      in our case target element will be our search input element.
      and like in our synthetic event onChange we receive value on changing 
      from event.target.value. so we need to simulate that.
  
          fireEvent.change(<target element>,{target:{
              value:{"Value we want to search"}
          }})
  
      
      simillarly, to fire a click event:
          fireEvent.click() can be used.
  
          fireEvent.click(searchBtn)
  
  `,
};
